package director;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Hashtable;

import columnGeneration.VRPTW;
import columnGeneration.VRPTWSolver;
import dataStructures.DataHandler;
import parameters.CGParameters;

/**
 * This class organizes the column generation/bcp procedure.
 * @author nicolas.cabrera-malik
 *
 */
public class Solver {
	
	/**
	 * Instance name
	 */
	
	private String instance;
	
	/**
	 * Type of implementation we will use
	 */
	private int type;
	
	private String instance_type;
	
	private int instance_id;
	
	private int num_nodes;
	
	
	/**
	 * This method creates a solver instance
	 * @param dataFile
	 * @param instanceType Instance type: R, RC, C
	 * @param instanceID Instance identifier
	 * @param ty 1: Column generation 2: BPC
	 * @param numNodes Number of customers
	 * @throws IOException
	 * @throws InterruptedException
	 */
	public Solver(String dataFile, String instanceType, int instanceID, int ty, int numNodes) throws IOException, InterruptedException {
		
		// Instance identifier
		
		instance = instanceType+"-"+instanceID+"_"+numNodes;
		instance_type = instanceType;
		instance_id = instanceID;
		num_nodes = numNodes;
		
		// Creates the data handler:
		
		readDataInfo(dataFile, instanceType, instanceID, numNodes);
		
		// Type of algorithm
		
		type = ty;
		
		// Runs the selected algorithm:
		
		if(type == 1) {
			
			runCG(); // Runs the column generation at the root node (also adds cuts)
			
		}else if(type == 2) {
			
			runBPC(); // Runs the branch-price-and-cut
		}
		
		
	}
	
	
	/**
	 * This method runs the CG procedure
	 * @throws IOException
	 * @throws InterruptedException
	 */
	public void runCG() throws IOException, InterruptedException {
		
		// Creates the VRPTW object:
		
			VRPTW cs = new VRPTW();
			
		// Current BAP node
			
			VRPTW.stillAtTheRootNode = true;
			CGParameters.USE_SUBSET_ROW_INEQ = false;
			
		// Creates a VRPTW solver
			
			VRPTWSolver pcs = new VRPTWSolver(cs);
			
		// Computes the computational time:
			
			Double compTime = ((VRPTW.FTime-VRPTW.ITime)/1000000000);
			
		// Prints the results:
			
			printResults_jorlib(cs,pcs, compTime);
			
			
	}
	
	/**
	 * This method runs the BPC procedure
	 * @throws IOException
	 * @throws InterruptedException
	 */
	public void runBPC() throws IOException, InterruptedException {
		
		// Creates the VRPTW object:
		
			VRPTW cs = new VRPTW();
			
		// Current BAP node
			
			VRPTW.stillAtTheRootNode = true;
			VRPTW.forbiddenArcs = new Hashtable<String,Integer>();
			
		// Creates a VRPTW solver
			
			branchAndPrice.VRPTWSolver pcs = new branchAndPrice.VRPTWSolver(cs);
			
		// Computes the computational time:
			
			Double compTime = ((VRPTW.FTime-VRPTW.ITime)/1000000000);
							
		// Prints the results:
			
			printResults_jorlib_bpc(cs,pcs, compTime);
			
			
	}

	/**
	 * This method prints some important results after the run (Implementation 1)
	 * @param CG
	 * @param msh
	 * @param compTime
	 */
	public void printResults_jorlib(VRPTW CG,VRPTWSolver CGSolver, Double compTime) {
		
		System.out.println("------------------------------------");
		System.out.println("Instance: "+instance);
		System.out.println("UpperBound: "+CGSolver.getUpperBound());
		System.out.println("LowerBound: "+CGSolver.getLowerBound());	
		System.out.println("GAP = "+100*((CGSolver.getUpperBound() - CGSolver.getLowerBound())/(CGSolver.getUpperBound()))+" %");
		System.out.println("CG iterations: "+CGSolver.getNumberOfIterations());
		System.out.println("Total number of columns: "+VRPTW.numColumns);
		System.out.println("Initial number of columns: "+VRPTW.numColumns_iniStep);
		System.out.println("Number of columns generated by the pricing: "+(VRPTW.numColumns - VRPTW.numColumns_iniStep));
		System.out.println("Number of cuts added: "+VRPTW.numCutsAdded);
		if(CGParameters.USE_LABELING_ALG) {
			System.out.println("Number of pricings solved by the labeling: "+VRPTW.number_pricing_byPulse);
		}else {
			System.out.println("Number of pricings solved by the pulse: "+VRPTW.number_pricing_byPulse);
		}
		System.out.println("Number of pricings solved by the tabu search: "+VRPTW.number_pricing_byTabu);
		System.out.println("Number of pricings solved to optimality: "+VRPTW.number_pricing_solvedToOptimality);
		System.out.println("Time spend on the relaxed master problem (s): "+VRPTW.time_on_master);
		System.out.println("Time spend on the pricing problem (s): "+VRPTW.time_on_pricing);
		System.out.println("Computational time (s): "+(compTime));
		System.out.println("------------------------------------");
		System.out.println("Don't forget to plot your solution on: https://nicolascabrera.shinyapps.io/VRPTW/");
		System.out.println("Your file should be located at: "+parameters.GlobalParameters.RESULT_FOLDER+"RMP/");
		System.out.println("Name of the file: Solution-"+instance+"_"+CGParameters.CONFIGURATION+".txt");
		System.out.println("------------------------------------");
		
		String ruta = parameters.GlobalParameters.RESULT_FOLDER+"RMP/Summary-"+instance+"_"+CGParameters.CONFIGURATION+".txt";

		PrintWriter pw;
		try {
			pw = new PrintWriter(new File(ruta));
			pw.println("Instance:"+instance);
			pw.println("InstanceType:"+instance_type);
			pw.println("InstanceId:"+instance_id);
			pw.println("InstanceNumNodes:"+num_nodes);
			pw.println("Configuration:"+CGParameters.CONFIGURATION);
			pw.println("UpperBound:"+CGSolver.getUpperBound());//+CG.getUpperBound());
			pw.println("LowerBound:"+CGSolver.getLowerBound());	
			pw.println("GAP:"+100*((CGSolver.getUpperBound() - CGSolver.getLowerBound())/(CGSolver.getUpperBound())));
			pw.println("Iterations:"+VRPTW.cgIteration);
			pw.println("NumberOfColumns:"+VRPTW.numColumns);
			pw.println("NumberOfColumns_IniStep:"+VRPTW.numColumns_iniStep);
			pw.println("NumberOfColumns_Additional:"+(VRPTW.numColumns - VRPTW.numColumns_iniStep));
			pw.println("NumberOfCuts:"+VRPTW.numCutsAdded);
			pw.println("NumberOfBAPnodes:"+VRPTW.numBAPnodes);
			pw.println("PricingPulse:"+VRPTW.number_pricing_byPulse);
			pw.println("PricingTabu:"+VRPTW.number_pricing_byTabu);
			pw.println("PricingToOptimality:"+VRPTW.number_pricing_solvedToOptimality);
			pw.println("TimeMasterProblem:"+VRPTW.time_on_master);
			pw.println("TimePricingProblem:"+VRPTW.time_on_pricing);
			pw.println("ComputationalTime:"+(compTime));
			pw.close();
		}catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * This method prints some important results after the run (Implementation 1)
	 * @param CG
	 * @param msh
	 * @param compTime
	 */
	public void printResults_jorlib_bpc(VRPTW CG,branchAndPrice.VRPTWSolver CGSolver, Double compTime) {
		
		System.out.println("------------------------------------");
		System.out.println("Instance: "+instance);
		System.out.println("UpperBound: "+CGSolver.getUpperBound());
		System.out.println("LowerBound: "+CGSolver.getLowerBound());	
		System.out.println("GAP = "+100*((CGSolver.getUpperBound() - CGSolver.getLowerBound())/(CGSolver.getUpperBound()))+" %");
		System.out.println("LowerBoundRootNode: "+VRPTW.lb_on_root_node);
		System.out.println("CG iterations: "+CGSolver.getNumberOfIterations());
		System.out.println("Total number of columns: "+VRPTW.numColumns);
		System.out.println("Initial number of columns: "+VRPTW.numColumns_iniStep);
		System.out.println("Number of columns generated by the pricing: "+(VRPTW.numColumns - VRPTW.numColumns_iniStep));
		System.out.println("Number of cuts added: "+VRPTW.numCutsAdded);
		System.out.println("Number of BAP nodes explored: "+VRPTW.numBAPnodes);
		if(CGParameters.USE_LABELING_ALG) {
			System.out.println("Number of pricings solved by the labeling: "+VRPTW.number_pricing_byPulse);
		}else {
			System.out.println("Number of pricings solved by the pulse: "+VRPTW.number_pricing_byPulse);
		}
		System.out.println("Number of pricings solved by the tabu search: "+VRPTW.number_pricing_byTabu);
		System.out.println("Number of pricings solved to optimality: "+VRPTW.number_pricing_solvedToOptimality);
		System.out.println("Time spend on the relaxed master problem (s): "+VRPTW.time_on_master);
		System.out.println("Time spend on the pricing problem (s): "+VRPTW.time_on_pricing);
		System.out.println("Time spend on the root node (s): "+VRPTW.time_on_root_node);
		System.out.println("Computational time: "+(compTime)+" s");
		System.out.println("------------------------------------");
		System.out.println("Don't forget to plot your solution on: https://nicolascabrera.shinyapps.io/VRPTW/");
		System.out.println("Your file should be located at: "+parameters.GlobalParameters.RESULT_FOLDER+"BPC/");
		System.out.println("Name of the file: Solution-"+instance+"_"+CGParameters.CONFIGURATION+".txt");
		System.out.println("------------------------------------");
		
		String ruta = parameters.GlobalParameters.RESULT_FOLDER+"BPC/Summary-"+instance+"_"+CGParameters.CONFIGURATION+".txt";

		PrintWriter pw;
		try {
			pw = new PrintWriter(new File(ruta));
			pw.println("Instance:"+instance);
			pw.println("InstanceType:"+instance_type);
			pw.println("InstanceId:"+instance_id);
			pw.println("InstanceNumNodes:"+num_nodes);
			pw.println("Configuration:"+CGParameters.CONFIGURATION);
			pw.println("UpperBound:"+CGSolver.getUpperBound());//+CG.getUpperBound());
			pw.println("LowerBound:"+CGSolver.getLowerBound());	
			pw.println("GAP:"+100*((CGSolver.getUpperBound() - CGSolver.getLowerBound())/(CGSolver.getUpperBound())));
			pw.println("Iterations:"+VRPTW.cgIteration);
			pw.println("NumberOfColumns:"+VRPTW.numColumns);
			pw.println("NumberOfColumns_IniStep:"+VRPTW.numColumns_iniStep);
			pw.println("NumberOfColumns_Additional:"+(VRPTW.numColumns - VRPTW.numColumns_iniStep));
			pw.println("NumberOfCuts:"+VRPTW.numCutsAdded);
			pw.println("NumberOfBAPnodes:"+VRPTW.numBAPnodes);
			pw.println("PricingPulse:"+VRPTW.number_pricing_byPulse);
			pw.println("PricingTabu:"+VRPTW.number_pricing_byTabu);
			pw.println("PricingToOptimality:"+VRPTW.number_pricing_solvedToOptimality);
			pw.println("TimeMasterProblem:"+VRPTW.time_on_master);
			pw.println("TimePricingProblem:"+VRPTW.time_on_pricing);
			pw.println("ComputationalTime:"+(compTime));
			pw.close();
		}catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * This method creates the data handler, the class that will store the main information about the current instance
	 * @param dataFile
	 * @param instanceType Instance type
	 * @param instanceID Instance identifier 
	 * @param numNodes Number of customers
	 * @return
	 * @throws IOException
	 */
	public DataHandler readDataInfo(String dataFile, String instanceType, int instanceID, int numNodes) throws IOException {
		
		//1.0 Creates a data handler
		
		DataHandler data = new DataHandler(dataFile,instanceType,instanceID,numNodes,CGParameters.BOUND_STEP_PULSE);
		
		//1.1 Read solomon nodes:
		
		data.readSolomon(numNodes);
		
		//1.2 Returns the data handler
		
		return(data);
	}
	

}
