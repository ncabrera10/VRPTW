/* ==========================================
 * jORLib : a free Java OR library
 * ==========================================
 *
 * Project Info:  https://github.com/jkinable/jorlib
 * Project Creator:  Joris Kinable (https://github.com/jkinable)
 *
 * (C) Copyright 2015, by Joris Kinable and Contributors.
 *
 * This program and the accompanying materials are licensed under LGPLv2.1
 *
 */
/* -----------------
 * SimpleBAPLogger.java
 * -----------------
 * (C) Copyright 2015, by Joris Kinable and Contributors.
 *
 * Original Author:  Joris Kinable
 * Contributor(s):   -
 *
 * $Id$
 *
 * Changes
 * -------
 *
 */
package branchAndPrice;

import org.jorlib.frameworks.columnGeneration.branchAndPrice.AbstractBranchAndPrice;
import org.jorlib.frameworks.columnGeneration.branchAndPrice.EventHandling.*;
import org.jorlib.frameworks.columnGeneration.branchAndPrice.branchingDecisions.BranchingDecision;

import columnGeneration.VRPTW;
import pricingAlgorithms.PA_PricingProblem;
import columnGeneration.RoutePattern;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.Enumeration;

/**
 * Simple class which logs events from the Branch-and-Price class
 *
 * @author Joris Kinable
 * @version 5-5-2015
 */
public class SimpleBAPLogger implements BAPListener{
    protected BufferedWriter writer;
    protected NumberFormat formatter;

    /** Branch-and-Price node ID of node currently being solved**/
    protected int bapNodeID;
    /** Parent node ID, -1 if root node **/
    protected int parentNodeID;
    /** Best integer solution **/
    protected double objectiveIncumbentSolution;
    /** Bound on the BAP node **/
    protected double nodeBound;
    /** What to do with the node, i.e prune (based on obj), Infeasible, Integer, Fractional, or Inconclusive if the nodeStatus could not be determined (e.g. due to time limit) **/
    protected NodeResultStatus nodeStatus;
    /** Number of nodes currently in the queue **/
    protected int nodesInQueue;
    
    protected String decision;
    protected String fixedArcs;
    protected String removedArcs;

    //Colgen stats
    /** Number of column generation iterations **/
    protected int cgIterations;

    //Master problem
    /** Counts how much time is spent on solving master problems **/
    protected long timeSolvingMaster;
    /** Objective value of bap node **/
    protected double nodeValue;

    //Pricing Problem
    /** Counts how much time is spend on solving pricing problems **/
    protected long timeSolvingPricing;
    /** Total number of columns generated by the pricing problems **/
    protected int nrGeneratedColumns;


    /**
     * Create a new logger which writes its output the the file specified
     * @param branchAndPrice Branch-and-Price instance for which this logger is created.
     * @param outputFile file to redirect the output to.
     */
    public SimpleBAPLogger(AbstractBranchAndPrice<VRPTW,RoutePattern,PA_PricingProblem> branchAndPrice, File outputFile){
        try {
            writer=new BufferedWriter(new FileWriter(outputFile));
        } catch (IOException e) {
            e.printStackTrace();
        }
        formatter=new DecimalFormat("#0.00");
        branchAndPrice.addBranchAndPriceEventListener(this);
    }

    /**
     * Write a single line of text to the output file
     * @param line line of text to be written
     */
    protected void writeLine(String line){
        try {
            writer.write(line);
            writer.newLine();
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Reset the values
     */
    protected void reset(){
        bapNodeID=-1;
        parentNodeID=-1;
        objectiveIncumbentSolution =-1;
        nodeBound =-1;
        cgIterations=0;
        timeSolvingMaster=0;
        nodeValue=-1;
        timeSolvingPricing=0;
        nrGeneratedColumns=0;
        nodesInQueue=-1;
        decision="unknown";
        fixedArcs="unknown";
        removedArcs="unknown";
    }

    /**
     * Construct a single line in the log file, and write it to the output file
     */
    protected void constructAndWriteLine(){
        this.writeLine(String.valueOf(bapNodeID) + "\t" + parentNodeID + "\t" + objectiveIncumbentSolution + "\t" + nodeBound + "\t" + formatter.format(nodeValue) + "\t" + cgIterations + "\t" + timeSolvingMaster + "\t" + timeSolvingPricing + "\t" + nrGeneratedColumns + "\t" + nodeStatus + "\t" + nodesInQueue + "\t" + decision + "\t" + fixedArcs + "\t" + removedArcs);
    }

    @Override
    public void startBAP(StartEvent startEvent) {
        this.writeLine("BAPNodeID \t parentNodeID \t objectiveIncumbentSolution \t nodeBound \t nodeValue \t cgIterations \t t_master \t t_pricing \t nrGenColumns \t solutionStatus \t nodesInQueue \t decision \t fixedArcs \t removedArcs");
    }

    @Override
    public void finishBAP(FinishEvent finishEvent) {
        try {
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void pruneNode(PruneNodeEvent pruneNodeEvent) {
        this.nodeStatus =NodeResultStatus.PRUNED;
        this.nodeBound =pruneNodeEvent.nodeBound;
        this.constructAndWriteLine();
    }

    @Override
    public void nodeIsInfeasible(NodeIsInfeasibleEvent nodeIsInfeasibleEvent) {
        this.nodeStatus =NodeResultStatus.INFEASIBLE;
        this.constructAndWriteLine();
    }

    @Override
    public void nodeIsInteger(NodeIsIntegerEvent nodeIsIntegerEvent) {
        this.nodeStatus =NodeResultStatus.INTEGER;
        this.constructAndWriteLine();
    }

    @Override
    public void nodeIsFractional(NodeIsFractionalEvent nodeIsFractionalEvent) {
        this.nodeStatus =NodeResultStatus.FRACTIONAL;
        this.constructAndWriteLine();
    }

    @Override
    public void processNextNode(ProcessingNextNodeEvent processingNextNodeEvent) {
        this.reset();
        this.bapNodeID=processingNextNodeEvent.node.nodeID;
        this.parentNodeID=processingNextNodeEvent.node.getParentID();
        this.objectiveIncumbentSolution =processingNextNodeEvent.objectiveIncumbentSolution;
        this.nodesInQueue=processingNextNodeEvent.nodesInQueue;
        
   
    }

    @Override
    public void finishedColumnGenerationForNode(FinishProcessingNodeEvent finishProcessingNodeEvent) {
        this.nodeBound = finishProcessingNodeEvent.nodeBound;
        this.nodeValue= finishProcessingNodeEvent.nodeValue;
        this.cgIterations= finishProcessingNodeEvent.numberOfCGIterations;
        this.timeSolvingMaster= finishProcessingNodeEvent.masterSolveTime;
        this.timeSolvingPricing= finishProcessingNodeEvent.pricingSolveTime;
        this.nrGeneratedColumns= finishProcessingNodeEvent.nrGeneratedColumns;
        @SuppressWarnings("rawtypes")
		BranchingDecision choice = finishProcessingNodeEvent.node.getBranchingDecision();
    	if(choice instanceof FixArc) {
    		this.decision="FixArc";
    	}
    	else if(choice instanceof RemoveArc) {
    		this.decision="RemoveArc";
    	}
    	fixedArcs = "";
		removedArcs = "";
		if(!VRPTW.fixedArcs.isEmpty()) {
			Enumeration<String> fixKeys = VRPTW.fixedArcs.keys();
			while (fixKeys.hasMoreElements()) {
				 
	            // Getting the key of a particular entry
				
	            fixedArcs += fixKeys.nextElement()+" || ";
	            
			}	
		}
		
		if(!VRPTW.removedArcs.isEmpty()) {
			Enumeration<String> removedKeys = VRPTW.removedArcs.keys();
			while (removedKeys.hasMoreElements()) {
				 
	            // Getting the key of a particular entry
				
	            removedArcs += removedKeys.nextElement()+"Rem || ";
	            
			}
		}
    }

    @Override
    public void timeLimitExceeded(TimeLimitExceededEvent timeLimitExceededEvent){
        this.nodeStatus =NodeResultStatus.INCONCLUSIVE;
        this.constructAndWriteLine();
    }

    @Override
    public void branchCreated(BranchEvent branchEvent) {
        //Ignore this event, not needed by the logger.
    }

    protected enum NodeResultStatus{
        PRUNED, INFEASIBLE, FRACTIONAL, INTEGER, INCONCLUSIVE
    }
}
